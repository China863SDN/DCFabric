/*
 * fabric_arp.c
 *
 *  Created on: Apr 2, 2015
 *      Author: joe
 */
#include "gnflush-types.h"
#include "fabric_arp.h"
#include "fabric_host.h"
#include "fabric_impl.h"
#include "gn_inet.h"
#include "openflow-10.h"
#include "openflow-13.h"


void fabric_arp_request_handle(gn_switch_t *sw, packet_in_info_t *packet_in);
void fabric_arp_reply_handle(gn_switch_t *sw, packet_in_info_t *packet_in);

void fabric_push_arp_flood_queue(UINT4 ip,arp_t* arp_info,packet_in_info_t *packet_in);
void fabric_push_flow_queue(p_fabric_host_node src,p_fabric_host_node dst);

void fabric_create_arp_reply(p_fabric_host_node src,p_fabric_host_node dst,packet_in_info_t *packet_in_info);

void fabric_packet_output(gn_switch_t *sw, packet_in_info_t *packet_in_info,UINT4 outport);

void fabric_ip_packet_flood(packet_in_info_t *packet_in_info);

/*****************************
 * global variables
 *****************************/
// switch server
//extern gn_server_t g_server;
extern sem_t fabric_flood_sem;
extern sem_t fabric_flow_sem;

void fabric_arp_handle(gn_switch_t *sw, packet_in_info_t *packet_in){
	arp_t *arp = (arp_t *)(packet_in->data);
	if(arp->opcode == htons(1)){
		fabric_arp_request_handle(sw,packet_in);
	}else{
		fabric_arp_reply_handle(sw,packet_in);
	}
	return;
};
void fabric_ip_handle(gn_switch_t *sw, packet_in_info_t *packet_in){
	p_fabric_host_node src = NULL,dst=NULL;
	ip_t *ip = (ip_t *)(packet_in->data);

	src = get_fabric_host_by_ip(ip->src);
	if(src == NULL){

		src = create_fabric_host_node(sw,packet_in->inport,ip->eth_head.src,ip->src);
		insert_fabric_host(src);
		// install output flow table 3
		install_fabric_output_flow(sw,ip->eth_head.src,packet_in->inport);
		//printf("fabric_ip_handle: find host [ ip: %d ]! \n",src->ip);
	}else if(src->port != packet_in->inport){
		// update host inport
		src->port = packet_in->inport;
		// install output flow table 3
		install_fabric_output_flow(sw,ip->eth_head.src,packet_in->inport);
		//printf("fabric_ip_handle: update host [ ip: %d ]! \n",ip->src);
	}

	dst = get_fabric_host_by_ip(ip->dest);
	if(dst != NULL){
		// download flows
		fabric_push_flow_queue(src,dst);

		// pecket out
		fabric_packet_output(dst->sw,packet_in,dst->port);
		//printf("fabric_ip_handle: find dst [ dst ip: %d]! \n",dst->ip);

//		printf("fabric_ip_handle: find dst ! src:%d | dst:%d \n",src->mac[5],dst->mac[5]);
	}else{
		//printf("fabric_ip_handle: not find dst ! \n");
		fabric_ip_packet_flood(packet_in);
		//printf("fabric_ip_handle: flood! \n");
	}
	return;
};
/*****************************
 * intern function : handle packet
 *****************************/
void fabric_arp_request_handle(gn_switch_t *sw, packet_in_info_t *packet_in){
	p_fabric_host_node src = NULL,dst=NULL;
	p_fabric_arp_request_node arp_node= NULL;
	//packout_req_info_t packout_req = NULL;
	arp_t *arp = (arp_t *)(packet_in->data);
	src = get_fabric_host_by_ip(arp->sendip);
	if(src == NULL){
		src = create_fabric_host_node(sw,packet_in->inport,arp->sendmac,arp->sendip);
		insert_fabric_host(src);
		// install output flow table 3
		install_fabric_output_flow(sw,arp->eth_head.src,packet_in->inport);
	}else if(src->port != packet_in->inport){
		// update host inport
		src->port = packet_in->inport;
		// install output flow table 3
		install_fabric_output_flow(sw,arp->eth_head.src,packet_in->inport);
	}

	dst = get_fabric_host_by_ip(arp->targetip);
	if(dst == NULL){
		// add to arp queue
		arp_node = create_fabric_arp_request_node(src,arp->targetip);
		insert_fabric_arp_request(arp_node);

		// flood to outter ports
		fabric_push_arp_flood_queue(arp->targetip,arp,packet_in);
		//fabric_paket_flood(packet_in);
		//printf("fabric_arp_request_handle: not find dst|senderIp:%d |targetIp:NULL !\n",src->ip);
	}else{
		// download flows
		fabric_push_flow_queue(src,dst);
		// create reply
		fabric_create_arp_reply(src,dst,packet_in);

		//fabric_paket_output(dst->sw,packet_in,dst->port);
		//printf("fabric_arp_request_handle: find dst |senderIp:%d |targetIp:%d !\n",src->ip,dst->ip);
	}
	return;
};
void fabric_arp_reply_handle(gn_switch_t *sw, packet_in_info_t *packet_in){
	p_fabric_host_node src = NULL,dst=NULL;
	p_fabric_arp_request_node temp_node = NULL;

	arp_t *arp = (arp_t *)(packet_in->data);
	src = get_fabric_host_by_ip(arp->sendip);
	if(src == NULL){
		src = create_fabric_host_node(sw,packet_in->inport,arp->sendmac,arp->sendip);
		insert_fabric_host(src);
		// install output flow table 3
		install_fabric_output_flow(sw,arp->eth_head.src,packet_in->inport);
	}else if(src->port != packet_in->inport){
		// update host inport
		src->port = packet_in->inport;
		// install output flow table 3
		install_fabric_output_flow(sw,arp->eth_head.src,packet_in->inport);
	}

	temp_node = remove_fabric_arp_request_by_dstip(src->ip);
	while(temp_node != NULL){

		dst = temp_node->src_req;
		// add fabric flow
		fabric_push_flow_queue(src,dst);
		// create fabric arp reply
		memcpy(arp->eth_head.dest,dst->mac, 6);
		arp->targetip = dst->ip;
		memcpy(arp->targetmac,dst->mac, 6);
		fabric_packet_output(dst->sw,packet_in,dst->port);

		//printf("fabric_arp_reply_handle: find request ndoe: %d \n",dst->ip);
		// delete arp request node
		temp_node = delete_fabric_arp_request_node(temp_node);
	}

//	dst = get_fabric_host_by_ip(arp->targetip);
//	if(dst != NULL){
//		// download flows
//		fabric_push_flow_queue(src,dst);
//		// create reply
//		//fabric_create_arp_reply(src,dst,packet_in);
//		fabric_paket_output(dst->sw,packet_in,dst->port);
//	}
//
//	p_sentinel->next = remove_fabric_arp_request_by_dstip(src->ip);
//	while(p_sentinel->next != NULL){
//		temp_node = p_sentinel->next;
//		p_sentinel->next = temp_node->next;
//
//		dst = temp_node->src_req;
//		// add fabric flow
//		fabric_push_flow_queue(src,dst);
//		// create fabric arp reply
//		memcpy(arp->eth_head.dest,dst->mac, 6);
//		arp->targetip = dst->ip;
//		memcpy(arp->targetmac,dst->mac, 6);
//		fabric_paket_output(dst->sw,packet_in,dst->port);
//
//		// delete arp request node
//		delete_fabric_arp_request_node(temp_node);
//	}

	return;
};
/*****************************
 * intern function
 *****************************/
/*
 * push flood queue
 */
void fabric_push_arp_flood_queue(UINT4 ip,arp_t* arp_info,packet_in_info_t *packet_in_info){
	p_fabric_flood_node node = NULL;
	packet_in_info_t* packet_in = NULL;
	arp_t *arp = NULL;
	node = get_fabric_arp_flood_by_ip(ip);
	if(node == NULL){

		//node = (p_fabric_flood_node)gn_malloc(sizeof(t_fabric_flood_node));
		packet_in = (packet_in_info_t*)gn_malloc(sizeof(packet_in_info_t));
		arp = (arp_t*)gn_malloc(sizeof(arp_t));

		memcpy(arp,arp_info, sizeof(arp_t));
		memcpy(packet_in,packet_in_info, sizeof(packet_in_info_t));
		packet_in->data =(UINT1*)arp;

		node = create_fabric_arp_flood_node(packet_in,ip);
		push_fabric_arp_flood(node);
		sem_post(&fabric_flood_sem);
	}
	return;
};
/*
 * push fabric flow queue
 */
void fabric_push_flow_queue(p_fabric_host_node src,p_fabric_host_node dst){
	UINT4 src_tag = 0,dst_tag = 0;
	p_fabric_flow_node node = NULL;

	node = get_fabric_flow_by_ip(src,dst);
	if(node == NULL){
		src_tag = of131_fabric_impl_get_tag_sw(src->sw);
		dst_tag = of131_fabric_impl_get_tag_sw(dst->sw);
		node = create_fabric_flow_node(src,src_tag,dst,dst_tag);
		push_fabric_flow(node);
		sem_post(&fabric_flow_sem);
	}
	return;
};
/*
 * create a reply to arp request host
 */
void fabric_create_arp_reply(p_fabric_host_node src,p_fabric_host_node dst,packet_in_info_t *packet_in_info){
    packout_req_info_t packout_req_info;
    arp_t new_arp_pkt;
    arp_t *arp = (arp_t *)(packet_in_info->data);
//printf("%s\n", FN);
    packout_req_info.buffer_id = 0xffffffff;
    packout_req_info.inport = OFPP13_CONTROLLER;
    packout_req_info.outport = src->port;
    packout_req_info.max_len = 0xff;
    packout_req_info.xid = packet_in_info->xid;
    packout_req_info.data_len = sizeof(arp_t);
    packout_req_info.data = (UINT1 *)&new_arp_pkt;

    memcpy(&new_arp_pkt, arp, sizeof(arp_t));
    memcpy(new_arp_pkt.eth_head.src, dst->mac, 6);
    memcpy(new_arp_pkt.eth_head.dest, src->mac, 6);
    new_arp_pkt.eth_head.proto = htons(ETHER_ARP);
    new_arp_pkt.opcode = htons(2);
    new_arp_pkt.sendip = dst->ip;
    new_arp_pkt.targetip = src->ip;
    memcpy(new_arp_pkt.sendmac, dst->mac, 6);
    memcpy(new_arp_pkt.targetmac, src->mac, 6);

    src->sw->msg_driver.msg_handler[OFPT13_PACKET_OUT](src->sw, (UINT1 *)&packout_req_info);
};
/*
 * out put the packet
 */
void fabric_packet_output(gn_switch_t *sw, packet_in_info_t *packet_in_info,UINT4 outport){
//    printf("%s\n", FN);
	packout_req_info_t pakout_req;
	pakout_req.buffer_id = packet_in_info->buffer_id;
	pakout_req.inport = OFPP13_CONTROLLER;
	pakout_req.outport = outport;
	pakout_req.max_len = 0xff;
	pakout_req.xid = packet_in_info->xid;
	pakout_req.data_len = packet_in_info->data_len;
	pakout_req.data = packet_in_info->data;
	sw->msg_driver.msg_handler[OFPT13_PACKET_OUT](sw, (UINT1 *)&pakout_req);
};

/*
 * flood the packet to each port without switch intern ports
 */
void fabric_ip_packet_flood( packet_in_info_t *packet_in_info){
	packout_req_info_t pakout_req;
	gn_switch_t *sw = NULL;
	UINT2 i = 0,j=0;
//	ip_t *ip = (ip_t *)(packet_in_info->data);
//printf("%s\n", FN);
	pakout_req.buffer_id = 0xffffffff;
	pakout_req.inport = OFPP13_CONTROLLER;
	pakout_req.max_len = 0xff;
	pakout_req.xid = packet_in_info->xid;
	pakout_req.data_len = packet_in_info->data_len;
	pakout_req.data = packet_in_info->data;

//	pakout_req.outport = OFPP13_FLOOD;
//	memset(ip->eth_head.src,0,6);

	// find all switch
	for(i = 0; i < g_server.max_switch; i++){
		if (g_server.switches[i].state){
			sw = &g_server.switches[i];
			// find switch's outter ports
			for(j=0; j<sw->n_ports; j++){
				// check port state is ok and also not connect other switch(neighbor)
				if(sw->ports[j].state == 0 && sw->neighbor[j] == NULL){
					pakout_req.outport = sw->ports[j].port_no;
					sw->msg_driver.msg_handler[OFPT13_PACKET_OUT](sw, (UINT1 *)&pakout_req);
				}
			}
			//sw->msg_driver.msg_handler[OFPT13_PACKET_OUT](sw, (UINT1 *)&pakout_req);
		}
	}

	return;
};
/////////////////////////////////////////////////////////////////////////////////
///*
// * flood the packet to each port without switch intern ports
// */
//void fabric_paket_flood( packet_in_info_t *packet_in_info){
//	packout_req_info_t pakout_req;
//	gn_switch_t *sw = NULL;
//	UINT2 i = 0,j=0;
////	arp_t new_arp_pkt;
//
//	pakout_req.buffer_id = packet_in_info->buffer_id;
//	//pakout_req.buffer_id = 0xffffffff;
//	pakout_req.inport = OFPP13_CONTROLLER;
//	pakout_req.max_len = 0xff;
//	pakout_req.xid = packet_in_info->xid;
//	pakout_req.data_len = packet_in_info->data_len;
//	pakout_req.data = packet_in_info->data;
//
//	// find all switch
//	for(i = 0; i < g_server.max_switch; i++){
//		if (g_server.switches[i].state){
//			sw = &g_server.switches[i];
//			// find switch's outter ports
//			for(j=0; j<sw->n_ports; j++){
//				// check port state is ok and also not connect other switch(neighbor)
////				if(sw->ports[j].neighbour == NULL){
//				if( 0 == check_is_neighbor_port(sw,sw->ports[j].port_no)){
////					printf("Port no:%d\n",sw->ports[j].port_no);
////					temp_fabric_paket_output(sw,packet_in_info,sw->ports[j].port_no);
//					pakout_req.outport = sw->ports[j].port_no;
//					//pakout_req.buffer_id++;
//					sw->msg_driver.msg_handler[OFPT13_PACKET_OUT](sw, (UINT1 *)&pakout_req);
//				}
//			}
//		}
//	}
//
//	return;
//};
//UINT1 check_is_neighbor_port(gn_switch_t* sw,UINT4 port){
//	UINT2 i = 0,j=0;
//	gn_switch_t* neighbor = NULL;
//	for(i=0;i < sw->n_ports;i++){
//		// get neighbor switch
//		if(sw->neighbor[i] != NULL && sw->neighbor[i]->sw != NULL){
//			neighbor = sw->neighbor[i]->sw;
//			for(j=0;j<neighbor->n_ports;j++){
//				if(neighbor->neighbor[j] != NULL && neighbor->neighbor[j]->sw == sw){
//					if(neighbor->neighbor[j]->port->port_no == port){
//						return 1;
//					}
//				}
//			}
//		}
//	}
//	return 0;
//}
//
